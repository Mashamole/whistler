#! /usr/bin/env python
# -*- encoding: utf-8 -*-
# vim:fenc=utf-8:
#
# This code is heavly based on quinoa, which is:
#   (c) 2010 Kit La Touche

import os
import sys
import time
import random
import warnings

warnings.filterwarnings("ignore",category=DeprecationWarning)
import xmpp

from whistler.log import WhistlerLog
from whistler.job import WhistlerIdleJob, WhistlerWorkJob

xmpp.NS_CONFERENCE = "jabber:x:conference"

COMMAND_CHAR = "!"

class WhistlerConnectionError(Exception):
    """ A exception which will be raised on bot connection error. """


class WhistlerBot(object):
    """ The main WhistlerBot class handle the bot behaviour and
    perform subcall to specific command handler when a command
    is received in a configured MUC channel. """


    def __init__(self, jid, password, server=None, rooms=None,
            resource=None, log=None):
        """ Create a new :class:`WhistlerBot` object, the :func:`__init__`
        receive the following parameters:

        :param `jid`: a valid JID atom to identify the bot user.
        :param `password`: a plaintext password to identify the bot user.
        :param `server`: a tuple in the form *server*, *port* which sepcify
            the host to connect to, if not provided the server then use the
            JID domain instead.
        :param `rooms`: a :class:`list` of rooms to be autojoin in.
        :param `resource`: the XMPP resource string, or autogenerated one if
            not provided.
        :param `log`: a :class:`WhistlerLog` to log bot messages to, or
            *stdout* if none is provided.
        """

        self.jid = xmpp.JID(jid)
        self.password = password
        self.server = server or ( self.jid.getDomain(), 5222 )
        self.log = log or WhistlerLog()

        self.idle = None
        self.client = None
        self.rooms = {}

        for room in rooms or []:
            self.rooms[room] = resource

        self.resource = resource or self.__class__.__name__.lower() + \
                                    random.getrandbits(32)


    def on_connect(self):
        """ This function can be override to handle the connection event.
        When bot is sucessfully connect, the actions defined in this
        function will be executed. """


    def connect(self):
        """ Perform a connection to the server, this function is designed to
        work internally, but calls to :func:`on_connect` when connection is
        sucessfully. """

        if self.client:
            return self.client

        self.client = xmpp.client.Client(self.jid.getDomain(), debug=[])

        if not self.client.connect(server=self.server, secure=True):
            raise WhistlerConnectionError(
                "unable to connect to %s using port %d" % self.server
            )
        else:
            self.log.info("connected to %s, port %d" % self.server)

        if not self.client.auth(self.jid.getNode(), self.password, self.resource):
            raise WhistlerConnectionError(
                "unable to authorize user %s" % self.jid.getNode()
            )
        else:
            self.log.info("authorized user %s" % self.jid.getNode())


        self.client.RegisterHandler("message",  self.handle_message)
        self.client.RegisterHandler("presence", self.handle_presence)

        self.client.sendInitPresence()

        self.on_connect()

        for room in self.rooms.keys():
            # Begin the join iteration process
            self._joining = self.join(*room.split('@'))
            self._joining.next()

        self.idle = WhistlerIdleJob(self.client, 60)
        return self.client


    def start(self):
        """ Start to serve the bot, until finished signal is received, using
        for that the :func:`stop`. """

        if not self.connect():
            raise WhistlerConnectionError("unknown error")

        self.idle.start()

        while True:
            self.client.Process(10)


    def stop(self):
        """ Stop the bot to serve, this function also destroy current
        connection if exists. """

        if self.idle:
            self.idle.stop()
        self.client = None


    def handle_presence(self, client, message):
        """ Handle the presence in XMPP server, this function is designed to
        work internally to bot, and handle the presence subscription
        XMPP message. """

        presence_type = message.getType()

        if presence_type == "subscribe":
            with message.getFrom() as who:
                self.client.send(xmpp.protocol.Presence(to=who, typ="subscribed"))
                self.client.send(xmpp.protocol.Presence(to=who, typ="subscribe"))


    def handle_message(self, client, message):
        """ Handle any received message from the XMPP server, this function
        is designed to work internally, and performs subcalls to any command
        function defined in the object when the properly command is
        received. """

        for node in message.getChildren():

            if node.getAttr("xmlns") == xmpp.NS_MUC_USER or \
               node.getNamespace() == xmpp.NS_CONFERENCE:

                   room = msg.getFrom().getNode()
                   serv = msg.getFrom().getDomain()

                   # Begin the join iteration process
                   self._joining = self.join(room, serv)
                   self._joining.next()
                   return

        if message.getType() == "groupchat":
            _room = message.getFrom()
            room  = "%s@%s" % ( _room.getNode(), _room.getDomain() )

            if room in self.rooms.keys() and \
               self.rooms[room] == _room.getResource():
                   return

        body = message.getBody()

        if not body or body[0] != COMMAND_CHAR:
            # None to handle
            return

        command   = body.split()[0][1:]
        arguments = body.split()[1:]

        command = getattr(self, "cmd_%s" % command, None)

        if command:
            self.log.info("received command %s with arguments %s" % \
                         ( command.__name__[4:], str(arguments) ))
            self.send(message, command, arguments)


    def handler_error(self, client, message):
        """ Handle error when register presence on groupchat, this function
        provide a way to rejoin on some kind of errors. """

        try:
            if message.getType == "error" and msg.getErrorCode() == "409":
                self._joining.send(False)
            else:
                self._joining.send(True)
        except StopIteration:
            pass


    def join(self, room, server, resource=None):
        """ Perform a bot join into a MUC room, aditional resource name can
        be provided to identify the bot in the MUC.

        :param `room`: The room name (whitout server statement).
        :param `server`: The conference server where room lives.
        :param `resource`: A resource name for the bot in the room.  """

        self.client.RegisterHandler("presence", self.handler_error)
        resource = resource or self.resource or "whistler"

        while True:
            room_presence = xmpp.protocol.JID(node = room, domain = server,
                    resource = resource)
            self.client.send(xmpp.protocol.Presence(room_presence))

            no_error = (yield)

            if no_error:
                break

            resource += "_"
            self.log.warnings("invalid resource name from room %s, " % room +
                              "trying new one (%s)" % resource)

        self.log.info("joined to %s with name %s" % ( room, resource ))

        self.client.RegisterHandler("presence", self.handle_presence)
        self.rooms["%s@%s" % ( room, server) ] = resource


    def send(self, message, command, arguments=[]):
        """ Send a XMPP message contains the result of command execution
        with arguments passed. The original message is also provided to
        known who sent the command.

        :param `message`: The original :class:`xmpp.protocol.Message`
        :param `command`: The command handled.
        :param `arguments`: a :class:`list` of arguments to the command. """

        dest = message.getFrom()

        if message.getType() == "groupchat":
            dest.setResource("")

        reply = command(message, arguments)

        self.client.send(xmpp.protocol.Message(dest, reply, message.getType()))


if __name__ == "__main__":
    class TestBot(WhistlerBot):
        def cmd_echo(self, msg, args):
            text = msg.getBody()
            return text

        def cmd_list_rooms(self, msg, args):
            return ', '.join(self.rooms.keys())

        def cmd_whoami(self, msg, args):
            return "You are %s" % msg.getFrom()

    try:
        b = TestBot('test@connectical.com',  'password',
                server = ("talk.google.com", 5223), resource = 'Bot')
        b.start()

    except KeyboardInterrupt:
        pass
    finally:
        b.stop()

